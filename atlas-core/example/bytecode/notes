// defined by the core --> opcode compiler
fn +(a, b) { # Address $+
    unpack_pos a
    unpack_pos b
    force a
    force b
    add c a b
    ret c
}

fn $cons(head, tail) {
    cons c head tail
    ret c
}

// in some standard library
fn run(exec, args, file_tree) {
    force evec
    force args
    force file_tree
    my_magic_rust_func res <-- exec, args, file_tree
    ret res
}

let a = ....
let b = ....

let c = a :: b

c = Cons(a, b)



let a = [1, 2];

# core expr
let a = $cons(1, $cons(2, $empty_list));


fn foo(a, b) {
    let c = a + b;
    let d = 2;
    return c + d;
}


fn foo(a, b) {
    entrypoint c <-- $+
    apply_pos c <-- c a
    apply_pos c <-- c b
    invoke c
    store d <-- 2
    entrypoint e <-- $+
    apply_pos e <-- e c
    apply_pos e <-- e d
    invoke e
    force e
    ret e
}

fn foo(a,b) {
    entrypoint c <-- $+
    apply_pos c <-- c a
    apply_pos c <-- c b
    store d <-- 2

    force c
    force d
    add e c d
    ret e
}

fn foo(a,b) {
    force a
    force b
    add c a b
    store d <-- 2
    add e c d
    ret e
}

fn no_inline_ident(a) {
    force a
    ret a
}


// case statements


match x {
    Some => ...
    None => ...
}


match type(x) {
    int => dfsdxdfsdfs,
    float => fdsksjdfsdfs
}

match x {
    None => {},
    Some(1) => {},
    Some([]) => {},
    [] => {},
    [a] => {}
    [a, **b] => {}
}

// match tree

scrut_type
    variant - scrut_tag
        None - goto branch
        Some - scrut_type
            int - scrut_literal
                1
            list - is_cons
                nil
    list - is_cons
        cons - is_cons
            cons - [a, **b] branch
            nil - [a] branch
        nil - [] branch

// gets transpiled into

force x
hastag a x "Some"
hastag b x "None"
jmpif a $some_branch
jmpif b $none_branch
panic!
